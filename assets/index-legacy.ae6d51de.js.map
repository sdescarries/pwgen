{"version":3,"file":"index-legacy.ae6d51de.js","sources":["../../src/Password/charset.ts","../../src/Password/pwgenImpl.ts","../../src/Password/Random.ts","../../src/Password/pwgenFactory.ts","../../src/Password/usePasswordGenerator.tsx","../../src/Password/useDebounce.ts","../../src/DipSwitch/useDipSwitchStorage.ts","../../src/DipSwitch/DipSwitch.tsx","../../src/InfiniScroll/useInfiniScroll.ts","../../src/InfiniScroll/InfiniScroll.tsx","../../src/Length/useLengthStorage.ts","../../src/Length/Length.tsx","../../src/App/App.tsx","../../vite/preload-helper","../../src/reportWebVitals.ts","../../src/main.tsx"],"sourcesContent":["import { CharsetLabels } from './types';\n\nexport const charsetLabels: CharsetLabels = {\n  ['09']: 'Number',\n  ['AZ']: 'Upper Case',\n  ['SM']: 'Symbol',\n};\n\nexport const charsetShorts: CharsetLabels = {\n  ['09']: '9',\n  ['AZ']: 'Z',\n  ['SM']: '#',\n};\n\nexport const alphaLower = 'abcdefghijklmnopqrstuvwxyz';\nexport const alphaUpper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\nexport const numerical = '0123456789';\nexport const symbol = '=+-*@$%!&?,.:;^#(){}[]|';\n\nexport const charsetMapping: CharsetLabels = {\n  ['09']: numerical,\n  ['AZ']: alphaUpper,\n  ['SM']: symbol,\n  ['az']: alphaLower,\n};\n\nexport const toRealSet = ([key, value]: [string, boolean]): string => \n  (value ? charsetMapping[key] : '');\n\nexport const getCharset = (...args: string[]): string[] =>\n  Array.from(new Set(args.flat().join('')));\n","import type { Random } from './Random';\n\nexport interface PwgenProps {\n  length: number;\n  charset: string[];\n  random: Random;\n}\n\nexport function pwgenImpl({ length, charset, random }: PwgenProps): string {\n  // Output word\n  let word = '';\n  let prev = -1;\n\n  // Add random chars form set for desired length\n  for (let n = 0; n < length; ++n) {\n    let key;\n\n    // Prevent consecutive chars from being the same\n    do {\n      key = random.pop();\n    } while (key === prev);\n\n    prev = key;\n    word += charset[key];\n  }\n\n  return word;\n}\n","export class Random {\n  array = new Uint32Array(1024);\n  index = 1024;\n  range: number;\n\n  constructor(range: number) {\n    this.range = range;\n  }\n\n  pop(): number {\n    if (this.index >= 1024) {\n      crypto.getRandomValues(this.array);\n      this.index = 0;\n    }\n    return this.array[this.index++] % this.range;\n  }\n}\n","import { getCharset } from './charset';\nimport { pwgenImpl } from './pwgenImpl';\nimport { Random } from './Random';\nimport { WordGenerator } from './types';\n\n\nexport function pwgenFactory(length: number, ...args: string[]): WordGenerator {\n\n  if (length === 0) {\n    return (): Promise<string> => Promise.resolve('');\n  }\n\n  if (length < 4) {\n    throw new Error(`length too short ${length}`);\n  }\n\n  const charset = getCharset(...args);\n\n  if (charset.length < 1) {\n    throw new Error('empty charset');\n  }\n\n  if (crypto?.getRandomValues == null) {\n    throw new Error('missing crypto facility');\n  }\n\n  const random = new Random(charset.length);\n\n  return (): Promise<string> =>\n    Promise.resolve({ length, charset, random }).then(pwgenImpl);\n}","import { useRef, useState } from 'react';\n\nimport { \n  alphaLower, \n  toRealSet,\n} from './charset';\nimport { pwgenFactory } from './pwgenFactory';\nimport { \n  PasswordOptions, \n  PasswordUserOptions, \n  UpdatePasswordOptions, \n  WordGenerator,\n} from './types';\nimport { useDebounce } from './useDebounce';\n\nexport const combinePasswordOptions = (\n  oldOptions?: PasswordUserOptions, \n  newOptions?: PasswordUserOptions\n): PasswordOptions => ({\n  charset: {\n    ...oldOptions?.charset,\n    ...newOptions?.charset,\n  },\n  length: newOptions?.length ?? oldOptions?.length ?? 8,\n});\n\nexport const deepEqual = (left: object, right: object): boolean => {\n  const leftStr = JSON.stringify(left);\n  const rightStr = JSON.stringify(right);\n  return leftStr === rightStr;\n};\n\nexport function usePasswordGenerator({ length, charset }: PasswordOptions): WordGenerator {\n  const realSets = Object.entries<boolean>(charset).map(toRealSet);\n  return pwgenFactory(length, alphaLower, ...realSets);\n}\n\ninterface PasswordContext extends PasswordOptions {\n  generator: WordGenerator;\n  update: UpdatePasswordOptions;\n}\n\nexport function usePasswordContext(): PasswordContext {\n  const pending = useRef<PasswordOptions>({ charset: {}, length: 0 });\n  const [current, setOptions] = useState<PasswordOptions>(pending.current);\n  const debounce = useDebounce(200);\n  const generator = usePasswordGenerator(current);\n\n  const update: UpdatePasswordOptions = (options: PasswordUserOptions) => {\n    pending.current = combinePasswordOptions(pending.current, options);\n    debounce(() => {\n      if (!deepEqual(current, pending.current)) {\n        setOptions(pending.current);\n      }\n    });\n  };\n\n  return ({\n    ...current,\n    generator,\n    update,\n  });\n}\n","import { useCallback, useEffect, useRef } from 'react';\n\nexport interface DebounceContext {\n  timeout?: number;\n}\n\nexport type DebounceCallback = () => void;\nexport type Debounce = (callback: DebounceCallback) => void;\nexport function useDebounce(delay: number): Debounce {\n  const context = useRef<DebounceContext>({ });\n\n  const debounce = useCallback<Debounce>((callback: DebounceCallback): void => {\n    clearTimeout(context.current.timeout);\n    context.current.timeout = setTimeout(callback, delay) as unknown as number;\n  }, [delay]);\n\n  useEffect(() => () => clearTimeout(context.current.timeout), [delay]);\n\n  return debounce;\n}\n","import { Dispatch, useEffect, useState } from 'react';\n\nimport { CharsetState } from '@/Password/';\n\nexport type UpdateCharsetState = (state: CharsetState) => void;\nexport interface DipSwitchProps {\n  charset: string;\n  update: UpdateCharsetState;\n}\n\nexport const charsetStoragePath = (charset: string): string => \n  `pwgen-charset-${charset}`;\n\n\nexport function loadDipSwitchStorage(charset: string): boolean {\n  try {\n    const serialized = localStorage.getItem(charsetStoragePath(charset)) ?? 'false';\n    return JSON.parse(serialized) as boolean;\n  } catch ({ message }) {\n    console.warn(message);\n    return false;\n  }\n}\n\nexport const saveDipSwitchStorage = (charset: string, value: boolean): Promise<void> => \n  Promise\n    .resolve()\n    .then(() => charsetStoragePath(charset))\n    .then((path) => localStorage.setItem(path, JSON.stringify(value)))\n    .catch(() => undefined);\n\nexport function useDipSwitchStorage({ charset, update }: DipSwitchProps): [boolean, Dispatch<boolean>] {\n\n  const [checked, setChecked] = useState<boolean>(() => loadDipSwitchStorage(charset));\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useEffect(() => update({ [charset]: checked }), []);\n\n  const chainUpdate = (newState: boolean) => {\n    update({ [charset]: newState });\n    setChecked(newState);\n    void saveDipSwitchStorage(charset, newState);\n  };\n\n  const toggle = () => chainUpdate(!checked);\n\n  return [checked, toggle];\n}\n","import { charsetLabels, charsetShorts } from '@/Password/';\n\nimport { \n  DipSwitchProps,\n  useDipSwitchStorage,\n} from './useDipSwitchStorage';\n\nexport interface LabelProps {\n  charset: string;\n  checked: boolean;\n  id: string,\n}\n\nexport function Label({ id, charset, checked }: LabelProps): JSX.Element {\n  const label = charsetLabels[charset];\n  const short = charsetShorts[charset];\n  const hint = `${checked ? 'disable' : 'enable'} ${label} characters`.toLocaleLowerCase();\n  return (\n    <label className={'Frame Flame'} htmlFor={id} title={hint}>\n      <div className={'Large'}>\n        <label className='toggleWrapper' htmlFor={id} >\n          <div className='toggle' />\n        </label>\n        <p className='label'>{label}</p>\n      </div>\n      <div className={'Small'}>\n        <p className='label'>{short}</p>\n      </div>\n    </label>\n  );\n}\n\nexport function DipSwitch(props: DipSwitchProps): JSX.Element {\n  const [checked, toggle] = useDipSwitchStorage(props);\n  const id = `dipSwitch-${props.charset}`;\n  return (\n    <div className={'DipSwitch'} data-testid={id}>\n      <input\n        checked={checked}\n        className={'checkbox'}\n        id={id}\n        onChange={() => toggle(!checked)}\n        type={'checkbox'}\n      />\n      <Label \n        id={id} \n        charset={props.charset} \n        checked={checked} \n      />\n    </div>\n  );\n}\n","import {\n  MutableRefObject,\n  RefObject,\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n} from 'react';\n\nimport { PasswordOptions, WordGenerator } from '@/Password';\n\nexport interface InfiniScrollState {\n\n  // container element for the infinite scroll\n  grid: RefObject<HTMLElement>;\n\n  // table data\n  list: InfiniCell[],\n\n  // infini scroll bottom of view observer\n  loader: RefObject<HTMLElement>;\n\n  // cell size observer\n  standard: RefObject<HTMLDivElement>;\n}\n\nexport interface InfiniCell {\n  // unique identifier for the cell\n  id: number;\n\n  // word length\n  length: number;\n\n  // consume and erase value\n  shred: (index: number) => void;\n\n  // actual value\n  value?: string;\n}\n\n\nexport interface ListModifiers {\n\n  // should the whole list be refreshed\n  full?: boolean;\n\n  // should a slice be replaced\n  slice?: boolean; \n\n  // consume and erase value\n  shred: (index: number) => void;\n\n  // number of visible lines in table\n  rows: MutableRefObject<number>;\n\n  // number of visible columns in table\n  cols: MutableRefObject<number>;\n\n  // write cursor index in array\n  index: MutableRefObject<number>;\n\n  // word length for placeholder\n  length: number;\n}\n\nexport interface Refresh {\n  done?: boolean,\n  full?: boolean,\n  slice?: boolean,\n}\n\nexport type Refresher = (options?: Refresh) => void;\n\nexport interface ResizeHandlerProps {\n  cols: MutableRefObject<number>;\n  rows: MutableRefObject<number>;\n\n  grid: RefObject<HTMLElement>;\n  standard: RefObject<HTMLDivElement>;\n\n  refresh: Refresher;\n}\n\nexport const getLastIndex = (list: InfiniCell[]): number => (list[list.length - 1]?.id ?? -1) + 1;\n\nexport const extendListToSize = (list: InfiniCell[], { length, cols, rows, shred }: ListModifiers): InfiniCell[] => {\n  const size = cols.current * rows.current;\n  if (list.length > size) {\n    return list.slice(0, size);\n  }\n  \n  let lastIndex = getLastIndex(list);\n  list = [...list];\n  while (list.length < size) {\n    list.push({ id: lastIndex++, length, shred, value: '' });\n  }\n  \n  return list;\n};\n\nexport const refreshList = (mods: ListModifiers) => (list: InfiniCell[]): InfiniCell[] => {\n\n  const {\n    cols,\n    full,\n    index,\n    rows,\n    slice,\n    shred,\n    length,\n  } = mods;\n\n  if (full) {\n    const lastIndex = getLastIndex(list);\n    list = [{ id: lastIndex, length, shred, value: '' }];\n    index.current = 0;\n  } else if (slice) {\n    const oneThird = Math.ceil(rows.current / 3) * cols.current;\n    list = list.slice(oneThird);\n    index.current = Math.max(0, index.current - oneThird);\n  }\n\n  return extendListToSize(list, mods);\n};\n\nexport function useInfiniScrollLoader(refresh: Refresher): [RefObject<HTMLElement>] {\n  const loader = useRef<HTMLElement>(null);\n\n  useEffect(() => {\n\n    if (!loader.current) {\n      console.warn('useInfiniScroll IntersectionObserver not ready');\n      return;\n    }\n\n    const handleIntersection = ([{ isIntersecting }]: IntersectionObserverEntry[]) => {\n      if (isIntersecting) {\n        refresh({ slice: true });\n      }\n    };\n\n    const intersectionObserver = new IntersectionObserver(handleIntersection);\n    intersectionObserver.observe(loader.current);\n\n    return () => intersectionObserver.disconnect();\n\n  }, [refresh]);\n\n  return [loader];\n}\n\ninterface ResizeContext {\n  cw: number;\n  ch: number;\n  iw: number;\n  ih: number;\n}\n\nconst makeResizeContext = (): ResizeContext => ({\n  cw: 0,\n  ch: 0,\n  iw: 0,\n  ih: 0,\n});\n\nconst updateResizeContext = (props: ResizeHandlerProps, context: ResizeContext, entries: ResizeObserverEntry[]) => {\n  const { grid, standard } = props;\n  for (const { contentRect, target } of entries) {\n    if (target === standard.current) {\n      context.iw = contentRect.width + 8;\n      context.ih = contentRect.height + 8;\n    }\n\n    if (target === grid.current) {\n      context.cw = contentRect.width;\n      context.ch = contentRect.height;\n    }\n  }\n};\n\nexport function makeResizeHandler(props: ResizeHandlerProps) {\n\n  const context = makeResizeContext();\n  const handleResize = (entries: ResizeObserverEntry[]) => {\n\n    updateResizeContext(props, context, entries);\n    \n    let needRefresh = false;\n    if (context.iw && context.ih) {\n      const rows = Math.floor(context.ch / context.ih) * 2;\n      const cols = Math.floor(context.cw / context.iw);\n\n      if (props.rows.current != rows) {\n        props.rows.current = rows;\n        needRefresh = true;\n      }\n\n      if (props.cols.current != cols) {\n        props.cols.current = cols;\n        needRefresh = true;\n      }\n    }\n\n    if (needRefresh) {\n      props.refresh();\n    }\n  };\n\n  return handleResize;\n}\n\nexport function useInfiniScrollSize(\n  refresh: Refresher,\n  cols: MutableRefObject<number>,\n  rows: MutableRefObject<number>,\n): [RefObject<HTMLElement>, RefObject<HTMLDivElement>] {\n  const grid = useRef<HTMLElement>(null);\n  const standard = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n\n    if (!grid.current || !standard.current) {\n      console.warn('useInfiniScroll ResizeObserver not ready');\n      return;\n    }\n\n    const handleResize = makeResizeHandler({ cols, rows, grid, standard, refresh });\n    const resizeObserver = new ResizeObserver(handleResize);\n    resizeObserver.observe(grid.current);\n    resizeObserver.observe(standard.current);\n    return () => resizeObserver.disconnect();\n  }, [cols, rows, refresh]);\n\n  return [grid, standard];\n}\n\nconst promiseAnimationFrame = () => new Promise(resolve => requestAnimationFrame(resolve));\n\nconst fillList = (index: MutableRefObject<number>, value: string) => (oldList: InfiniCell[]) => {\n  const cell = oldList[index.current];\n\n  if (!cell) {\n    return oldList;\n  }\n\n  const newList = [...oldList];\n  newList[index.current] = {\n    ...cell,\n    value,\n  };\n\n  index.current++;\n  return newList;\n};\n\nconst shredder = (index: number) => (oldList: InfiniCell[]) => {\n  const cell = oldList[index];\n\n  if (!cell) {\n    return oldList;\n  }\n\n  const newList = [...oldList];\n  newList[index] = {\n    ...cell,\n    value: '',\n  };\n\n  return newList;\n};\n\nexport interface InfiniScrollProps extends PasswordOptions {\n  generator: WordGenerator;\n}\n\nexport function useInfiniScroll({ generator, length }: InfiniScrollProps): InfiniScrollState {\n\n  const [list, listUpdate] = useState<InfiniCell[]>([]);\n  const cols = useRef<number>(0);\n  const rows = useRef<number>(0);\n  const index = useRef<number>(0);\n\n  const [needRefresh, setRefresh] = useState<Refresh>({ done: true });\n  const refresh = useCallback((options?: Refresh) => \n    setRefresh((previous) => \n      ({ ...previous, ...options, done: false })), []);\n\n  const [loader] = useInfiniScrollLoader(refresh);\n  const [grid, standard] = useInfiniScrollSize(refresh, cols, rows);\n\n  useEffect(() => refresh({ full: true }), [generator, length, refresh]);\n\n  const shred = useCallback((index: number) => listUpdate(shredder(index)), []);\n\n  useEffect(() => {\n\n    if (needRefresh.done) {\n      return;\n    }\n\n    if (!length) {\n      return;\n    }\n\n    listUpdate(\n      refreshList({ \n        ...needRefresh,\n        cols,\n        index,\n        length,\n        shred,\n        rows,\n      })\n    );\n\n    setRefresh({ done: true });\n\n  }, [length, needRefresh, shred]);\n\n  useEffect(() => {\n    let alive = true;\n\n    if (!length) {\n      return;\n    }\n\n    Promise\n      .resolve()\n      .then(async () => {\n        const size = rows.current * cols.current;\n        while(alive && index.current < size) {\n          const value = await generator();\n          await promiseAnimationFrame();\n          listUpdate(fillList(index, value));\n        }\n      })\n      .catch(console.warn);\n\n    return () => {\n      alive = false;\n    };\n  }, [generator, length, needRefresh]);\n\n  return { grid, list, loader, standard };\n}\n","import { useCallback } from 'react';\n\nimport { InfiniCell, InfiniScrollProps, useInfiniScroll } from './useInfiniScroll';\n\nexport type renderInfiniScroll = (key: number) => JSX.Element;\n\nexport interface CellProps extends InfiniCell {\n  index: number;\n}\n\nexport function Cell(props: CellProps): JSX.Element {\n\n  const { id, index, length, shred, value = '' } = props;\n\n  const pbcopy = useCallback(() => {\n    if (value) {\n      navigator\n        .clipboard\n        .writeText(value)\n        .then(() => shred(index))\n        .catch(console.warn);\n    }\n  }, [index, shred, value]);\n\n  const displayWord = value.padEnd(length, '*');\n\n  const classNames = ['Password'];\n\n  if (value) {\n    classNames.push('Ready');\n  }\n\n  return (\n    <button \n      className={classNames.join(' ')} \n      disabled={!value} \n      id={`${id}`} \n      onClick={pbcopy}\n    >\n      {displayWord}\n    </button>\n  );\n}\n\nexport function InfiniScroll(props: InfiniScrollProps): JSX.Element {\n  const { \n    grid, \n    list, \n    loader,\n    standard, \n  } = useInfiniScroll(props);\n\n  const render = (cell: InfiniCell, index: number) => \n    <Cell key={cell.id} {...cell} index={index} />;\n\n  return (\n    <section className={'InfiniScroll'} ref={grid}>\n      <div className={'Standard'} ref={standard}>\n        <Cell id={-1} {...props} index={-1} shred={() => undefined} />\n      </div>\n      <div className={'Grid'}>\n        {list.map(render)}\n        <nav ref={loader} />\n      </div>\n    </section>\n  );\n}\n","import { useEffect, useState } from 'react';\n\ntype UpdateLength = (length: number) => void;\n\nexport interface LengthProps {\n  update: UpdateLength;\n}\n\nexport const lengthStoragePath = 'pwgen-length';\n\n\nexport function loadLengthStorage(): number {\n  try {\n    const serialized = localStorage.getItem(lengthStoragePath) ?? '8';\n    return JSON.parse(serialized) as number;\n  } catch ({ message }) {\n    console.warn(message);\n    return 8;\n  }\n}\n\nexport const saveLengthStorage = (value: number): Promise<void> => \n  Promise\n    .resolve()\n    .then(() => localStorage.setItem(lengthStoragePath, JSON.stringify(value)))\n    .catch(() => undefined);\n\ninterface LengthMap {\n  [key: number]: number;\n}\n\nconst lengthMap: LengthMap = {\n  8: 12,\n  12: 16,\n  16: 24,\n  24: 32,\n  32: 8,\n};\n\nexport type Toggle = () => void;\n\nexport function useLengthStorage({ update }: LengthProps): [number, Toggle] {\n\n  const [length, setValue] = useState<number>(loadLengthStorage);\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useEffect(() => update(length), []);\n\n  const chainUpdate = (newState: number) => {\n    update(newState);\n    setValue(newState);\n    void saveLengthStorage(newState);\n  };\n\n  const toggle = () => chainUpdate(lengthMap[length] ?? 8);\n\n  return [length, toggle];\n}\n","import { LengthProps, useLengthStorage } from './useLengthStorage';\n\nexport function Length(props: LengthProps): JSX.Element {\n\n  const [length, toggle] = useLengthStorage(props);\n\n  const id = 'Length';\n  const hint = 'change the length of the password';\n\n  return (\n    <button\n      className={'Frame Flame Length'} data-testid={id}\n      onClick={() => toggle()}\n      type={'submit'}\n      title={hint}\n    >{length}</button>\n  );\n}\n","import { DipSwitch } from '@/DipSwitch/';\nimport { InfiniScroll } from '@/InfiniScroll/';\nimport { Length } from '@/Length/';\nimport { \n  CharsetState,\n  UpdatePasswordOptions,\n  usePasswordContext,\n} from '@/Password/';\n\nexport interface ControlProps {\n  update: UpdatePasswordOptions;\n}\n\nexport function Control({ update }: ControlProps): JSX.Element {\n  const updateCharset = (charset: CharsetState) => update({ charset });\n  const updateLength = (length: number) => update({length});\n  return (\n    <div className={'Controls'}>\n      <Length update={updateLength}/>\n      <DipSwitch charset={'AZ'} update={updateCharset} />\n      <DipSwitch charset={'09'} update={updateCharset} />\n      <DipSwitch charset={'SM'} update={updateCharset} />\n    </div>\n  );\n}\n\nexport function App(): JSX.Element {\n  const context = usePasswordContext();\n  return (\n    <div className=\"App\">\n      <main>\n        <InfiniScroll {...context} />\n      </main>\n      <header>\n        <Control {...context} />\n      </header>\n    </div>\n  );\n}\n","const scriptRel = 'modulepreload';const seen = {};const base = '/pwgen/';export const __vitePreload = function preload(baseModule, deps) {\n    // @ts-ignore\n    if (!__VITE_IS_MODERN__ || !deps || deps.length === 0) {\n        return baseModule();\n    }\n    return Promise.all(deps.map((dep) => {\n        // @ts-ignore\n        dep = `${base}${dep}`;\n        // @ts-ignore\n        if (dep in seen)\n            return;\n        // @ts-ignore\n        seen[dep] = true;\n        const isCss = dep.endsWith('.css');\n        const cssSelector = isCss ? '[rel=\"stylesheet\"]' : '';\n        // @ts-ignore check if the file is already preloaded by SSR markup\n        if (document.querySelector(`link[href=\"${dep}\"]${cssSelector}`)) {\n            return;\n        }\n        // @ts-ignore\n        const link = document.createElement('link');\n        // @ts-ignore\n        link.rel = isCss ? 'stylesheet' : scriptRel;\n        if (!isCss) {\n            link.as = 'script';\n            link.crossOrigin = '';\n        }\n        link.href = dep;\n        // @ts-ignore\n        document.head.appendChild(link);\n        if (isCss) {\n            return new Promise((res, rej) => {\n                link.addEventListener('load', res);\n                link.addEventListener('error', rej);\n            });\n        }\n    })).then(() => baseModule());\n}","// https://bit.ly/CRA-vitals\nimport type { ReportHandler } from 'web-vitals';\n\nexport function reportWebVitals(onPerfEntry?: ReportHandler): void {\n  if (!(onPerfEntry instanceof Function)) {\n    return;\n  }\n\n  import('web-vitals')\n    .then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    })\n    .catch(({ stack }) => console.warn(stack));\n}\n","import '@/main.scss';\n\nimport ReactDOM from 'react-dom';\n\nimport { App } from '@/App';\nimport { reportWebVitals } from '@/reportWebVitals';\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);\n\nreportWebVitals();\n"],"names":["charsetLabels","charsetShorts","alphaLower","charsetMapping","toRealSet","key","getCharset","args","Array","from","Set","flat","join","length","charset","random","word","prev","n","pop","range","Uint32Array","this","index","getRandomValues","array","Promise","resolve","Error","crypto","Random","then","pwgenImpl","realSets","Object","entries","map","pwgenFactory","pending","useRef","useState","current","setOptions","debounce","delay","context","useCallback","callback","timeout","setTimeout","clearTimeout","useDebounce","generator","usePasswordGenerator","update","options","oldOptions","newOptions","left","right","JSON","stringify","charsetStoragePath","serialized","localStorage","getItem","parse","message","warn","loadDipSwitchStorage","checked","setChecked","chainUpdate","newState","value","path","setItem","catch","saveDipSwitchStorage","id","label","short","hint","toLocaleLowerCase","className","htmlFor","title","props","useDipSwitchStorage","toggle","onChange","type","Label","getLastIndex","list","refreshList","mods","cols","full","rows","slice","shred","oneThird","Math","ceil","max","size","lastIndex","push","extendListToSize","cw","ch","iw","ih","grid","standard","contentRect","target","width","height","needRefresh","floor","refresh","fillList","oldList","cell","newList","listUpdate","done","setRefresh","previous","loader","intersectionObserver","IntersectionObserver","isIntersecting","observe","disconnect","useInfiniScrollLoader","handleResize","makeResizeHandler","resizeObserver","ResizeObserver","useInfiniScrollSize","index2","shredder","alive","requestAnimationFrame","_context","console","pbcopy","clipboard","writeText","displayWord","padEnd","classNames","disabled","onClick","useInfiniScroll","ref","Cell","lengthStoragePath","lengthMap","loadLengthStorage","setValue","useLengthStorage","updateCharset","Length","DipSwitch","usePasswordContext","InfiniScroll","Control","onPerfEntry","baseModule","ReactDOM","render","App","document","getElementById","Function","getCLS","getFID","getFCP","getLCP","getTTFB","stack"],"mappings":"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"}