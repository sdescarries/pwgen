{"version":3,"file":"index-legacy.1d393a84.js","sources":["../../src/Password/charset.ts","../../src/Password/pwgenImpl.ts","../../src/Password/Random.ts","../../src/Password/pwgenFactory.ts","../../src/Password/useDebounce.ts","../../src/Password/usePasswordGenerator.tsx","../../src/DipSwitch/useDipSwitchStorage.ts","../../src/DipSwitch/DipSwitch.tsx","../../src/InfiniScroll/useInfiniScroll.ts","../../src/InfiniScroll/InfiniScroll.tsx","../../src/Length/useLengthStorage.ts","../../src/Length/Length.tsx","../../src/App/App.tsx","../../vite/preload-helper","../../src/reportWebVitals.ts","../../src/main.tsx"],"sourcesContent":["import { CharsetLabels } from './types';\n\nexport const charsetLabels: CharsetLabels = {\n  ['09']: 'Number',\n  ['AZ']: 'Upper Case',\n  ['SM']: 'Symbol',\n};\n\nexport const charsetShorts: CharsetLabels = {\n  ['09']: '9',\n  ['AZ']: 'Z',\n  ['SM']: '#',\n};\n\nexport const alphaLower = 'abcdefghijklmnopqrstuvwxyz';\nexport const alphaUpper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\nexport const numerical = '0123456789';\nexport const symbol = '=+-*@$%!&?,.:;^#(){}[]|';\n\nexport const charsetMapping: CharsetLabels = {\n  ['09']: numerical,\n  ['AZ']: alphaUpper,\n  ['SM']: symbol,\n  ['az']: alphaLower,\n};\n\nexport const toRealSet = ([key, value]: [string, boolean]): string => \n  (value ? charsetMapping[key] : '');\n\nexport const getCharset = (...args: string[]): string[] =>\n  Array.from(new Set(args.flat().join('')));\n","import type { Random } from './Random';\n\nexport interface PwgenProps {\n  length: number;\n  charset: string[];\n  random: Random;\n}\n\nexport function pwgenImpl({ length, charset, random }: PwgenProps): string {\n  // Output word\n  let word = '';\n  let prev = -1;\n\n  // Add random chars form set for desired length\n  for (let n = 0; n < length; ++n) {\n    let key;\n\n    // Prevent consecutive chars from being the same\n    do {\n      key = random.pop();\n    } while (key === prev);\n\n    prev = key;\n    word += charset[key];\n  }\n\n  return word;\n}\n","export class Random {\n  array = new Uint32Array(1024);\n  index = 1024;\n  range: number;\n\n  constructor(range: number) {\n    this.range = range;\n  }\n\n  pop(): number {\n    if (this.index >= 1024) {\n      crypto.getRandomValues(this.array);\n      this.index = 0;\n    }\n    return this.array[this.index++] % this.range;\n  }\n}\n","import { getCharset } from './charset';\nimport { pwgenImpl } from './pwgenImpl';\nimport { Random } from './Random';\nimport { WordGenerator } from './types';\n\n\nexport function pwgenFactory(length: number, ...args: string[]): WordGenerator {\n\n  if (length === 0) {\n    return (): Promise<string> => Promise.resolve('');\n  }\n\n  if (length < 4) {\n    throw new Error(`length too short ${length}`);\n  }\n\n  const charset = getCharset(...args);\n\n  if (charset.length < 1) {\n    throw new Error('empty charset');\n  }\n\n  if (crypto?.getRandomValues == null) {\n    throw new Error('missing crypto facility');\n  }\n\n  const random = new Random(charset.length);\n\n  return (): Promise<string> =>\n    Promise.resolve({ length, charset, random }).then(pwgenImpl);\n}","import { useCallback, useEffect, useRef } from 'react';\n\nexport interface DebounceContext {\n  timeout?: number;\n}\n\nexport type DebounceCallback = () => void;\nexport type Debounce = (callback: DebounceCallback) => void;\nexport function useDebounce(delay: number): Debounce {\n  const context = useRef<DebounceContext>({ });\n\n  const debounce = useCallback<Debounce>((callback: DebounceCallback): void => {\n    clearTimeout(context.current.timeout);\n    context.current.timeout = setTimeout(callback, delay) as unknown as number;\n  }, [delay]);\n\n  useEffect(() => () => clearTimeout(context.current.timeout), [delay]);\n\n  return debounce;\n}\n","import { useRef, useState } from 'react';\n\nimport { \n  alphaLower, \n  toRealSet,\n} from './charset';\nimport { pwgenFactory } from './pwgenFactory';\nimport { \n  PasswordOptions, \n  PasswordUserOptions, \n  UpdatePasswordOptions, \n  WordGenerator,\n} from './types';\nimport { useDebounce } from './useDebounce';\n\nexport const combinePasswordOptions = (\n  oldOptions?: PasswordUserOptions, \n  newOptions?: PasswordUserOptions\n): PasswordOptions => ({\n  charset: {\n    ...oldOptions?.charset,\n    ...newOptions?.charset,\n  },\n  length: newOptions?.length ?? oldOptions?.length ?? 8,\n});\n\nexport const deepEqual = (left: object, right: object): boolean => {\n  const leftStr = JSON.stringify(left);\n  const rightStr = JSON.stringify(right);\n  return leftStr === rightStr;\n};\n\nexport function usePasswordGenerator({ length, charset }: PasswordOptions): WordGenerator {\n  const realSets = Object.entries<boolean>(charset).map(toRealSet);\n  return pwgenFactory(length, alphaLower, ...realSets);\n}\n\ninterface PasswordContext extends PasswordOptions {\n  generator: WordGenerator;\n  update: UpdatePasswordOptions;\n}\n\nexport function usePasswordContext(): PasswordContext {\n  const pending = useRef<PasswordOptions>({ charset: {}, length: 0 });\n  const [current, setOptions] = useState<PasswordOptions>(pending.current);\n  const debounce = useDebounce(200);\n  const generator = usePasswordGenerator(current);\n\n  const update: UpdatePasswordOptions = (options: PasswordUserOptions) => {\n    pending.current = combinePasswordOptions(pending.current, options);\n    debounce(() => {\n      if (!deepEqual(current, pending.current)) {\n        setOptions(pending.current);\n      }\n    });\n  };\n\n  return ({\n    ...current,\n    generator,\n    update,\n  });\n}\n","import { Dispatch, useEffect, useState } from 'react';\n\nimport { CharsetState } from '@/Password/';\n\nexport type UpdateCharsetState = (state: CharsetState) => void;\nexport interface DipSwitchProps {\n  charset: string;\n  update: UpdateCharsetState;\n}\n\nexport const charsetStoragePath = (charset: string): string => \n  `pwgen-charset-${charset}`;\n\n\nexport function loadDipSwitchStorage(charset: string): boolean {\n  try {\n    const serialized = localStorage.getItem(charsetStoragePath(charset)) ?? 'false';\n    return JSON.parse(serialized) as boolean;\n  } catch ({ message }) {\n    console.warn(message);\n    return false;\n  }\n}\n\nexport const saveDipSwitchStorage = (charset: string, value: boolean): Promise<void> => \n  Promise\n    .resolve()\n    .then(() => charsetStoragePath(charset))\n    .then((path) => localStorage.setItem(path, JSON.stringify(value)))\n    .catch(() => undefined);\n\nexport function useDipSwitchStorage({ charset, update }: DipSwitchProps): [boolean, Dispatch<boolean>] {\n\n  const [checked, setChecked] = useState<boolean>(() => loadDipSwitchStorage(charset));\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useEffect(() => update({ [charset]: checked }), []);\n\n  const chainUpdate = (newState: boolean) => {\n    update({ [charset]: newState });\n    setChecked(newState);\n    void saveDipSwitchStorage(charset, newState);\n  };\n\n  const toggle = () => chainUpdate(!checked);\n\n  return [checked, toggle];\n}\n","import { charsetLabels, charsetShorts } from '@/Password/';\n\nimport { \n  DipSwitchProps,\n  useDipSwitchStorage,\n} from './useDipSwitchStorage';\n\nexport interface LabelProps {\n  charset: string;\n  checked: boolean;\n  id: string,\n}\n\nexport function Label({ id, charset, checked }: LabelProps): JSX.Element {\n  const label = charsetLabels[charset];\n  const short = charsetShorts[charset];\n  const hint = `${checked ? 'disable' : 'enable'} ${label} characters`.toLocaleLowerCase();\n  return (\n    <label className={'Frame Flame'} htmlFor={id} title={hint}>\n      <div className={'Large'}>\n        <label className='toggleWrapper' htmlFor={id} >\n          <div className='toggle' />\n        </label>\n        <p className='label'>{label}</p>\n      </div>\n      <div className={'Small'}>\n        <p className='label'>{short}</p>\n      </div>\n    </label>\n  );\n}\n\nexport function DipSwitch(props: DipSwitchProps): JSX.Element {\n  const [checked, toggle] = useDipSwitchStorage(props);\n  const id = `dipSwitch-${props.charset}`;\n  return (\n    <div className={'DipSwitch'} data-testid={id}>\n      <input\n        checked={checked}\n        className={'checkbox'}\n        id={id}\n        onChange={() => toggle(!checked)}\n        type={'checkbox'}\n      />\n      <Label \n        id={id} \n        charset={props.charset} \n        checked={checked} \n      />\n    </div>\n  );\n}\n","import {\n  MutableRefObject,\n  RefObject,\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n} from 'react';\n\nimport { PasswordOptions, WordGenerator } from '@/Password';\nimport { useDebounce } from '@/Password/useDebounce';\n\nexport interface InfiniScrollState {\n\n  // container element for the infinite scroll\n  grid: RefObject<HTMLElement>;\n\n  // table data\n  list: InfiniCell[],\n\n  // infini scroll bottom of view observer\n  loader: RefObject<HTMLElement>;\n\n  // cell size observer\n  standard: RefObject<HTMLDivElement>;\n}\n\nexport interface InfiniCell {\n  // unique identifier for the cell\n  id: number;\n\n  // word length\n  length: number;\n\n  // consume and erase value\n  shred: (index: number) => void;\n\n  // actual value\n  value?: string;\n}\n\n\nexport interface ListModifiers {\n\n  // should the whole list be refreshed\n  full?: boolean;\n\n  // should a slice be replaced\n  slice?: boolean;\n\n  // consume and erase value\n  shred: (index: number) => void;\n\n  // number of visible lines in table\n  rows: MutableRefObject<number>;\n\n  // number of visible columns in table\n  cols: MutableRefObject<number>;\n\n  // write cursor index in array\n  index: MutableRefObject<number>;\n\n  // word length for placeholder\n  length: number;\n}\n\nexport interface Refresh {\n  done?: boolean,\n  full?: boolean,\n  slice?: boolean,\n}\n\nexport type Refresher = (options?: Refresh) => void;\n\nexport interface ResizeHandlerProps {\n  cols: MutableRefObject<number>;\n  rows: MutableRefObject<number>;\n\n  grid: RefObject<HTMLElement>;\n  standard: RefObject<HTMLDivElement>;\n\n  refresh: Refresher;\n}\n\nexport const getLastIndex = (list: InfiniCell[]): number => (list[list.length - 1]?.id ?? -1) + 1;\n\nexport const extendListToSize = (list: InfiniCell[], { length, cols, rows, shred }: ListModifiers): InfiniCell[] => {\n  const size = cols.current * rows.current;\n  if (list.length > size) {\n    return list.slice(0, size);\n  }\n\n  let lastIndex = getLastIndex(list);\n  list = [...list];\n  while (list.length < size) {\n    list.push({ id: lastIndex++, length, shred, value: '' });\n  }\n\n  return list;\n};\n\nexport const refreshList = (mods: ListModifiers) => (list: InfiniCell[]): InfiniCell[] => {\n  const { cols, full, index, length, rows, shred, slice } = mods;\n  if (full) {\n    const lastIndex = getLastIndex(list);\n    list = [{ id: lastIndex, length, shred, value: '' }];\n    index.current = 0;\n  } else if (slice) {\n    const oneThird = Math.ceil(rows.current / 3) * cols.current;\n    list = list.slice(oneThird);\n    index.current = Math.max(0, index.current - oneThird);\n  }\n\n  return extendListToSize(list, mods);\n};\n\ntype noop = () => void;\n\nconst makeIntersectionHandler = (callback: noop) =>\n  ([{ isIntersecting }]: IntersectionObserverEntry[]) => {\n    if (isIntersecting) {\n      callback();\n    }\n  };\n\nexport function observeLoaderEffect(loader: RefObject<HTMLElement>, callback: noop) {\n  if (!loader.current) {\n    console.warn('useInfiniScroll IntersectionObserver not ready');\n    return;\n  }\n  const handleIntersection = makeIntersectionHandler(callback);\n  const intersectionObserver = new IntersectionObserver(handleIntersection);\n  intersectionObserver.observe(loader.current);\n  return () => intersectionObserver.disconnect();\n}\n\nexport function loaderIntersectsViewport(loader: RefObject<HTMLElement>, callback: noop): void {\n  const rect = loader.current?.getBoundingClientRect();\n  if (!rect) return;\n  if (rect.bottom > window.innerHeight) return;\n  if (rect.right > window.innerWidth) return;\n  callback();\n}\n\nexport function intersectionInterval(loader: RefObject<HTMLElement>, callback: noop): noop {\n  const interval = setInterval(() => loaderIntersectsViewport(loader, callback), 200);\n  return () => clearInterval(interval);\n}\n\nexport function useInfiniScrollLoader(refresh: Refresher): [RefObject<HTMLElement>] {\n  const loader = useRef<HTMLElement>(null);\n  const debounce = useDebounce(100);\n  const callback = useCallback(() =>\n    debounce(() =>\n      refresh({ slice: true })\n    ), [debounce, refresh]);\n\n  useEffect(() => observeLoaderEffect(loader, callback), [callback]);\n  useEffect(() => intersectionInterval(loader, callback), [callback]);\n\n  return [loader];\n}\n\ninterface ResizeContext {\n  cw: number;\n  ch: number;\n  iw: number;\n  ih: number;\n}\n\nconst makeResizeContext = (): ResizeContext => ({\n  cw: 0,\n  ch: 0,\n  iw: 0,\n  ih: 0,\n});\n\nconst updateResizeContext = (props: ResizeHandlerProps, context: ResizeContext, entries: ResizeObserverEntry[]) => {\n  const { grid, standard } = props;\n  for (const { contentRect, target } of entries) {\n    if (target === standard.current) {\n      context.iw = contentRect.width + 8;\n      context.ih = contentRect.height + 8;\n    }\n\n    if (target === grid.current) {\n      context.cw = contentRect.width;\n      context.ch = contentRect.height;\n    }\n  }\n};\n\nexport function makeResizeHandler(props: ResizeHandlerProps) {\n\n  const context = makeResizeContext();\n  const handleResize = (entries: ResizeObserverEntry[]) => {\n\n    updateResizeContext(props, context, entries);\n\n    let needRefresh = false;\n    if (context.iw && context.ih) {\n      const rows = Math.floor(context.ch / context.ih) * 2;\n      const cols = Math.floor(context.cw / context.iw);\n\n      if (props.rows.current != rows) {\n        props.rows.current = rows;\n        needRefresh = true;\n      }\n\n      if (props.cols.current != cols) {\n        props.cols.current = cols;\n        needRefresh = true;\n      }\n    }\n\n    if (needRefresh) {\n      props.refresh();\n    }\n  };\n\n  return handleResize;\n}\n\nexport function useInfiniScrollSize(\n  refresh: Refresher,\n  cols: MutableRefObject<number>,\n  rows: MutableRefObject<number>,\n): [RefObject<HTMLElement>, RefObject<HTMLDivElement>] {\n  const grid = useRef<HTMLElement>(null);\n  const standard = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n\n    if (!grid.current || !standard.current) {\n      console.warn('useInfiniScroll ResizeObserver not ready');\n      return;\n    }\n\n    const handleResize = makeResizeHandler({ cols, rows, grid, standard, refresh });\n    const resizeObserver = new ResizeObserver(handleResize);\n    resizeObserver.observe(grid.current);\n    resizeObserver.observe(standard.current);\n    return () => resizeObserver.disconnect();\n  }, [cols, rows, refresh]);\n\n  return [grid, standard];\n}\n\nconst promiseAnimationFrame = () => new Promise(resolve => requestAnimationFrame(resolve));\n\nconst fillList = (index: MutableRefObject<number>, value: string) => (oldList: InfiniCell[]) => {\n  const cell = oldList[index.current];\n\n  if (!cell) {\n    return oldList;\n  }\n\n  const newList = [...oldList];\n  newList[index.current] = {\n    ...cell,\n    value,\n  };\n\n  index.current++;\n  return newList;\n};\n\nconst shredder = (index: number) => (oldList: InfiniCell[]) => {\n  const cell = oldList[index];\n\n  if (!cell) {\n    return oldList;\n  }\n\n  const newList = [...oldList];\n  newList[index] = {\n    ...cell,\n    value: '',\n  };\n\n  return newList;\n};\n\nexport interface InfiniScrollProps extends PasswordOptions {\n  generator: WordGenerator;\n}\n\nexport function useInfiniScroll({ generator, length }: InfiniScrollProps): InfiniScrollState {\n\n  const [list, listUpdate] = useState<InfiniCell[]>([]);\n  const cols = useRef<number>(0);\n  const rows = useRef<number>(0);\n  const index = useRef<number>(0);\n\n  const [needRefresh, setRefresh] = useState<Refresh>({ done: true });\n  const refresh = useCallback((options?: Refresh) =>\n    setRefresh((previous) =>\n      ({ ...previous, ...options, done: false })), []);\n\n  const [loader] = useInfiniScrollLoader(refresh);\n  const [grid, standard] = useInfiniScrollSize(refresh, cols, rows);\n\n  useEffect(() => refresh({ full: true }), [generator, length, refresh]);\n\n  const shred = useCallback((index: number) => listUpdate(shredder(index)), []);\n\n  useEffect(() => {\n\n    if (needRefresh.done) return;\n    if (!length) return;\n\n    listUpdate(refreshList({...needRefresh, cols, rows, index, length, shred }));\n    setRefresh({ done: true });\n  }, [length, needRefresh, shred]);\n\n  useEffect(() => {\n    if (!length) return;\n\n    let alive = true;\n    Promise\n      .resolve()\n      .then(async () => {\n        const size = rows.current * cols.current;\n        while(alive && index.current < size) {\n          const [value] = await Promise.all([\n            generator(),\n            promiseAnimationFrame(),\n          ]);\n          listUpdate(fillList(index, value));\n        }\n      })\n      .catch(console.warn);\n\n    return () => {\n      alive = false;\n    };\n  }, [generator, length, needRefresh]);\n\n  return { grid, list, loader, standard };\n}\n","import { useCallback } from 'react';\n\nimport { InfiniCell, InfiniScrollProps, useInfiniScroll } from './useInfiniScroll';\n\nexport type renderInfiniScroll = (key: number) => JSX.Element;\n\nexport interface CellProps extends InfiniCell {\n  index: number;\n}\n\nexport function Cell(props: CellProps): JSX.Element {\n\n  const { id, index, length, shred, value = '' } = props;\n\n  const pbCopy = useCallback(() => {\n    if (value) {\n      navigator\n        .clipboard\n        .writeText(value)\n        .then(() => shred(index))\n        .catch(console.warn);\n    }\n  }, [index, shred, value]);\n\n  const displayWord = value.padEnd(length, '*');\n\n  const classNames = ['Password'];\n\n  if (value) {\n    classNames.push('Ready');\n  }\n\n  return (\n    <button\n      className={classNames.join(' ')}\n      disabled={!value}\n      id={`${id}`}\n      onClick={pbCopy}\n    >\n      {displayWord}\n    </button>\n  );\n}\n\nexport function InfiniScroll(props: InfiniScrollProps): JSX.Element {\n  const {\n    grid,\n    list,\n    loader,\n    standard,\n  } = useInfiniScroll(props);\n\n  const render = (cell: InfiniCell, index: number) =>\n    <Cell key={cell.id} {...cell} index={index} />;\n\n  return (\n    <section className={'InfiniScroll'} ref={grid}>\n      <div className={'Standard'} ref={standard}>\n        <Cell id={-1} {...props} index={-1} shred={() => undefined} />\n      </div>\n      <div className={'Grid'}>\n        {list.map(render)}\n        <nav ref={loader} />\n      </div>\n    </section>\n  );\n}\n","import { useEffect, useState } from 'react';\n\ntype UpdateLength = (length: number) => void;\n\nexport interface LengthProps {\n  update: UpdateLength;\n}\n\nexport const lengthStoragePath = 'pwgen-length';\n\n\nexport function loadLengthStorage(): number {\n  try {\n    const serialized = localStorage.getItem(lengthStoragePath) ?? '8';\n    return JSON.parse(serialized) as number;\n  } catch ({ message }) {\n    console.warn(message);\n    return 8;\n  }\n}\n\nexport const saveLengthStorage = (value: number): Promise<void> => \n  Promise\n    .resolve()\n    .then(() => localStorage.setItem(lengthStoragePath, JSON.stringify(value)))\n    .catch(() => undefined);\n\ninterface LengthMap {\n  [key: number]: number;\n}\n\nconst lengthMap: LengthMap = {\n  8: 12,\n  12: 16,\n  16: 24,\n  24: 32,\n  32: 8,\n};\n\nexport type Toggle = () => void;\n\nexport function useLengthStorage({ update }: LengthProps): [number, Toggle] {\n\n  const [length, setValue] = useState<number>(loadLengthStorage);\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useEffect(() => update(length), []);\n\n  const chainUpdate = (newState: number) => {\n    update(newState);\n    setValue(newState);\n    void saveLengthStorage(newState);\n  };\n\n  const toggle = () => chainUpdate(lengthMap[length] ?? 8);\n\n  return [length, toggle];\n}\n","import { LengthProps, useLengthStorage } from './useLengthStorage';\n\nexport function Length(props: LengthProps): JSX.Element {\n\n  const [length, toggle] = useLengthStorage(props);\n\n  const id = 'Length';\n  const hint = 'change the length of the password';\n\n  return (\n    <button\n      className={'Frame Flame Length'} data-testid={id}\n      onClick={() => toggle()}\n      type={'submit'}\n      title={hint}\n    >{length}</button>\n  );\n}\n","import { DipSwitch } from '@/DipSwitch/';\nimport { InfiniScroll } from '@/InfiniScroll/';\nimport { Length } from '@/Length/';\nimport { \n  CharsetState,\n  UpdatePasswordOptions,\n  usePasswordContext,\n} from '@/Password/';\n\nexport interface ControlProps {\n  update: UpdatePasswordOptions;\n}\n\nexport function Control({ update }: ControlProps): JSX.Element {\n  const updateCharset = (charset: CharsetState) => update({ charset });\n  const updateLength = (length: number) => update({length});\n  return (\n    <div className={'Controls'}>\n      <Length update={updateLength}/>\n      <DipSwitch charset={'AZ'} update={updateCharset} />\n      <DipSwitch charset={'09'} update={updateCharset} />\n      <DipSwitch charset={'SM'} update={updateCharset} />\n    </div>\n  );\n}\n\nexport function App(): JSX.Element {\n  const context = usePasswordContext();\n  return (\n    <div className=\"App\">\n      <main>\n        <InfiniScroll {...context} />\n      </main>\n      <header>\n        <Control {...context} />\n      </header>\n    </div>\n  );\n}\n","const scriptRel = 'modulepreload';const seen = {};const base = '/pwgen/';export const __vitePreload = function preload(baseModule, deps) {\n    // @ts-ignore\n    if (!__VITE_IS_MODERN__ || !deps || deps.length === 0) {\n        return baseModule();\n    }\n    return Promise.all(deps.map((dep) => {\n        // @ts-ignore\n        dep = `${base}${dep}`;\n        // @ts-ignore\n        if (dep in seen)\n            return;\n        // @ts-ignore\n        seen[dep] = true;\n        const isCss = dep.endsWith('.css');\n        const cssSelector = isCss ? '[rel=\"stylesheet\"]' : '';\n        // @ts-ignore check if the file is already preloaded by SSR markup\n        if (document.querySelector(`link[href=\"${dep}\"]${cssSelector}`)) {\n            return;\n        }\n        // @ts-ignore\n        const link = document.createElement('link');\n        // @ts-ignore\n        link.rel = isCss ? 'stylesheet' : scriptRel;\n        if (!isCss) {\n            link.as = 'script';\n            link.crossOrigin = '';\n        }\n        link.href = dep;\n        // @ts-ignore\n        document.head.appendChild(link);\n        if (isCss) {\n            return new Promise((res, rej) => {\n                link.addEventListener('load', res);\n                link.addEventListener('error', rej);\n            });\n        }\n    })).then(() => baseModule());\n}","// https://bit.ly/CRA-vitals\nimport type { ReportHandler } from 'web-vitals';\n\nexport function reportWebVitals(onPerfEntry?: ReportHandler): void {\n  if (!(onPerfEntry instanceof Function)) {\n    return;\n  }\n\n  import('web-vitals')\n    .then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    })\n    .catch(({ stack }) => console.warn(stack));\n}\n","import '@/main.scss';\n\nimport ReactDOM from 'react-dom';\n\nimport { App } from '@/App';\nimport { reportWebVitals } from '@/reportWebVitals';\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);\n\nreportWebVitals();\n"],"names":["charsetLabels","charsetShorts","alphaLower","charsetMapping","toRealSet","key","getCharset","args","Array","from","Set","flat","join","length","charset","random","word","prev","n","pop","range","Uint32Array","this","index","getRandomValues","array","Promise","resolve","Error","crypto","Random","then","pwgenImpl","delay","context","useRef","debounce","useCallback","callback","current","timeout","setTimeout","clearTimeout","realSets","Object","entries","map","pwgenFactory","pending","useState","setOptions","useDebounce","generator","usePasswordGenerator","update","options","oldOptions","newOptions","left","right","JSON","stringify","charsetStoragePath","serialized","localStorage","getItem","parse","message","warn","loadDipSwitchStorage","checked","setChecked","chainUpdate","newState","value","path","setItem","catch","saveDipSwitchStorage","id","label","short","hint","toLocaleLowerCase","className","htmlFor","title","props","useDipSwitchStorage","toggle","onChange","type","Label","getLastIndex","list","refreshList","mods","cols","full","rows","shred","slice","oneThird","Math","ceil","max","size","lastIndex","push","extendListToSize","loader","handleIntersection","isIntersecting","makeIntersectionHandler","intersectionObserver","IntersectionObserver","observe","disconnect","interval","setInterval","rect","_loader$current","getBoundingClientRect","bottom","window","innerHeight","innerWidth","loaderIntersectsViewport","clearInterval","cw","ch","iw","ih","grid","standard","contentRect","target","width","height","needRefresh","floor","refresh","fillList","oldList","cell","newList","listUpdate","done","setRefresh","previous","observeLoaderEffect","intersectionInterval","useInfiniScrollLoader","handleResize","makeResizeHandler","resizeObserver","ResizeObserver","useInfiniScrollSize","index2","shredder","alive","all","requestAnimationFrame","_context","console","pbCopy","clipboard","writeText","displayWord","padEnd","classNames","disabled","onClick","useInfiniScroll","ref","Cell","lengthStoragePath","lengthMap","loadLengthStorage","setValue","useLengthStorage","updateCharset","Length","DipSwitch","usePasswordContext","InfiniScroll","Control","onPerfEntry","baseModule","ReactDOM","render","App","document","getElementById","Function","getCLS","getFID","getFCP","getLCP","getTTFB","stack"],"mappings":"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"}